<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>关于MySQL事物隔离</title>
      <link href="/2018/10/21/%E5%85%B3%E4%BA%8EMySQL%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB/"/>
      <url>/2018/10/21/%E5%85%B3%E4%BA%8EMySQL%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="事物隔离"><a href="#事物隔离" class="headerlink" title="事物隔离"></a>事物隔离</h1><blockquote><p>简单概念:</p><p>事物就是保证一组数据库操作,要么全部成功,要么全部失败</p></blockquote><p>那么事物在数据库中如何实现?</p><p>以MySQL为例,MySQL是一个支持多引擎的数据库,常见的MySQL引擎有MyISAM 和 InnoDB, 其中MyISAM不支持事物, 而InnoDB支持事物,也就是说,在MySQL中,事物是在引擎层实现的. 这也是MyISAM被InnoDB取代的重要原因之一.</p><p>事物特性: </p><ul><li>原子性(Atomicity)</li><li>一致性(Consistency)</li><li>隔离性(Isolation)</li><li>持久性(Durability)</li></ul><p>关于隔离性</p><p>当数据库上有多个事物同时执行时,可能出现</p><ul><li>脏读(dirty read)</li><li>不可重复读(non reapeatable read)</li><li>幻读(phantom read)</li></ul><p>为了解决这些问题,有了隔离级别,但隔离有利弊,隔离越严,效率越低. 所以要选择合适的隔离级别.</p><p>SQL标准的事物隔离级别包括:</p><ul><li><p>读未提交(read uncommitted)</p><p>未提交就可读</p><p>一个事物A还未提交,它已做的变更就能被别的事物B看到,也就是事务A执行过程中,别的事物B可以看到事物A的变更.</p><p>读未提交级别下,没有视图概念, 因为直接返回记录上的最新值. </p></li><li><p>rc读提交（read committed）</p><p>提交之后才能被读</p><p>一个事物A提交之后,其做的变量才能被其他事物B看到, 也就是在该隔离级别下, 事物A执行过程中, 事物B无法看到事物A所做的变更. </p><ul><li><p>如何实现?</p><p>在读提交隔离级别下, 在每个 SQL 语句开始执行的时候, 数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准. </p></li></ul></li><li><p>rr可重复读（repeatable read）</p><p>一个事物A启动时看到的数据, 和事物A执行过程中看到的数据是一样的, 也就是事物A执行过程中, 如果有别的事物B改动了数据, 是无法影响到事物A的, 因为事物A看到的数据是定格在事物A启动那一刻的视图, 在其执行过程中不受其他事物影响.  同时, 在可重复读隔离级别下, 事物A未提交的变更对其他事物也是不可见的. </p><p>一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。</p><ul><li><p>如何实现?</p><p>数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准, 在”可重复读”隔离级别下, 这个视图是在事物启动时创建的,整个事物存在期间都用这个视图. </p></li><li><p>使用场景?</p><p>数据校对场景: 假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p></li></ul><p>这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</p></li><li><p>串行化（serializable ）</p><p>一个接一个, 也就是对于同一行记录, 写会加写锁, 读会加读锁, 当读写锁冲突时, 后访问的事物必须要等前一个事物执行完成,才能继续执行.</p><ul><li>如何实现?</li></ul><p>串行化隔离级别下直接用加锁的形式避免并行访问.</p></li></ul><p>用一个例子说明这几种隔离级别。假设数据表 T 中只有一列，其中一行的值为 1，下面是按照时间顺序执行两个事务的行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(c int) engine=InnoDB;</span><br><span class="line">insert into T(c) values(1);</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">事物A</th><th style="text-align:center">事物B</th></tr></thead><tbody><tr><td style="text-align:center">启动事务,查询得到值1</td><td style="text-align:center">启动事务</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">查询得到值1</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">将1改为2</td></tr><tr><td style="text-align:center">查询得到值V1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">提交事务B</td></tr><tr><td style="text-align:center">查询得到值V2</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">提交事务A</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">查询得到值V3</td></tr></tbody></table><ul><li>若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。</li><li>若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。</li><li>若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，是因为此时事物A还未提交, 遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li><li>若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。</li></ul><p>在不同隔离级别下, 数据库的行为不同, Oracle 数据库的默认隔离级别其实就是“读提交”，因此对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，你一定要记得将 MySQL 的隔离级别设置为“读提交”。</p><p>如何配置?</p><p>将启动参数 transaction-isolation 的值设置成 READ-COMMITTED。你可以用 show variables 来查看当前的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;transaction_isolation&apos;;</span><br><span class="line"> </span><br><span class="line">+-----------------------+----------------+</span><br><span class="line"> </span><br><span class="line">| Variable_name | Value |</span><br><span class="line"> </span><br><span class="line">+-----------------------+----------------+</span><br><span class="line"> </span><br><span class="line">| transaction_isolation | READ-COMMITTED |</span><br><span class="line"> </span><br><span class="line">+-----------------------+----------------+</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
  
  
</search>
