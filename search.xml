<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Ajax分页与缓存池</title>
      <link href="/2018/12/22/Ajax%E5%88%86%E9%A1%B5%E4%B8%8E%E7%BC%93%E5%AD%98%E6%B1%A0/"/>
      <url>/2018/12/22/Ajax%E5%88%86%E9%A1%B5%E4%B8%8E%E7%BC%93%E5%AD%98%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>Ajax分页与缓存池</p><p>关于Ajax的原理及代码实现不再赘述, 本文主要解决前端页面请求某一页数据后, 再次请求时的数据缓存优化. </p><p>试想这样一种情况,用户在访问不同的页面时,比如查询不同的电影页信息, 是很有可能再次返回刚才的页面, </p><p>如果每次访问同一重复页面, 都需要向后台发送请求, 比如说豆瓣的电影页, 用户量大了难免会浪费服务器资源, 所以作为一名合格的前端工程师,应该在每次请求数据是将数据缓存起来, 再次访问同一页面的时候, 先判断之前是否请求过该页面, 如果请求过,则直接从缓存池中取数据即可, 这样不仅访问速度加快, 后台的访问压力也会减小. </p><p>0.前端的主要职责需要考虑</p><p>交互,效率,体验</p><p>效率:能够减少请求</p><p>尽量减少请求</p><p>如何做到?</p><p>请求过的数据保存在js的独立内存里</p><p>自己创造一个缓存池</p><p>语言本身都有内存机制</p><p>只要页面不管不刷新,全局变量的值不会被回收</p><pre><code>function myAjax(opt) {    opt = opt || {};    opt.method = opt.method || &apos;GET&apos;;//请求方式 默认是GET    opt.url = opt.url || &apos;&apos;; //请求地址 默认为空链接    opt.async = opt.async || true;// 是否异步, 默认为真, 表示异步请求    opt.data = opt.data || null;//请求参数 默认无参数    opt.dataType = opt.dataType || &apos;JSON&apos;;//服务器返回数据类型 默认为JSON    opt.success = opt.success || function () {};    var xmlHttp = null;    if (XMLHttpRequest) {        xmlHttp = new XMLHttpRequest();    }    else {        xmlHttp = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); //兼容ie    }    var params = [];    for (var key in opt.data)params.push(key + &apos;=&apos; + opt.data[key]);        // console.log(params);//[&quot;page=1&quot;, &quot;limit=5&quot;]        // console.log(opt.async); //true表示异步    var postData = params.join(&apos;&amp;&apos;);        // console.log(postData); //page=1&amp;limit=5    if (opt.dataType === &apos;JSONP&apos;) {        creatScript(opt.url, postData);    } else {        if (opt.method.toUpperCase() === &apos;POST&apos;) {            xmlHttp.open(opt.method, opt.url, opt.async);            xmlHttp.responseType = &apos;document&apos;;            xmlHttp.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded;charset=utf-8&apos;);            xmlHttp.send(postData);        }        else if (opt.method.toUpperCase() === &apos;GET&apos;) {            xmlHttp.open(opt.method, opt.url + &apos;?&apos; + postData, opt.async);            if(opt.dataType.toUpperCase() == &apos;XML&apos; || &apos;HTML&apos;)                             xmlHttp.responseType = &apos;document&apos;;            xmlHttp.send(null);        }        xmlHttp.onreadystatechange = function () {            if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) {                if (opt.dataType === &apos;JSON&apos;) {                    //JSON.parse(xmlHttp.response)                    opt.success(xmlHttp.response);                }else{                    opt.success(xmlHttp.response);                }            }        };    }}function creatScript(url, data) {    var oScript = document.createElement(&apos;script&apos;);    oScript.src = url + &apos;?&apos; + data + &apos;&amp;callback=getEn&apos;;    document.body.appendChild(oScript);}</code></pre><p>1.dataType</p><p>2.函数自执行(是闭包的另外一种形式)</p><p>来解决for循环里i的变化</p><p>用特殊的手法把i给保存了,本来i会被清空,但是这个i我们用特殊的方法保留了下来</p><pre><code>for (var i = 0; i&lt;oLi.length ; i++){    //函数自执行,传进去参数,并接受参数.两个参数i没关系,    //外面的i是全局作用变量i,里面的i是函数作用域的i    (function(i) {        oLi[i].onclick = function() {            getData(i+1);            console.log(i);            console.log(this.innerHTML);        }    })(i);    //i本身会被清空}</code></pre><p>3.闭包的概念</p><p>通过一些特殊的手法让变量的值不会在一些情况中(比如说函数执行完毕之后被自动回收)</p><p>某一个即将被回收的值,阻止它返回或阻止它被回收</p><p>4.闭包的作用</p><p>保证作用域里的变量不会被污染不会被GC回收也不会被覆盖</p><p>5.由于事件的冒泡机制,有时候通过设置事件代理更简单</p><p>比如点击li,</p><p>实质也是在点击ul,</p><p>所以不需要给每个li单独设置点击事件</p><p>而是给ul设置监听事件</p><p>也就是事件绑定只用绑一个,</p><p>由于js的事件冒泡机制,其他的顺着子集一并绑定,</p><p>6.js的事件机制</p><p>捕获阶段</p><p>触发事件目标阶段</p><p>冒泡阶段</p><p>7.事件监听里面有个参数e</p><p>e是事件对象</p><p>里面会有很多关于本次事件的属性</p><p>8.事件对象的兼容处理</p><pre><code>function(e){var e = e || window.event;}</code></pre><p>9.e.target就是当前点击触发的某个元素</p><p>10.e.target.tagName属性就是获取点击触发事件的元素的名字</p><p>注意此属性的值是大写</p><p>11.字符串转小写的方法:toLowerCase();</p><p>12.获取到点击元素的内容</p><p>e.target.innerText;</p><p>e.target.innerHTML;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">            //在外部var一个cache等于cacheData();</span><br><span class="line">    </span><br><span class="line">            //cacheData返回一个对象</span><br><span class="line">    </span><br><span class="line">            //在这个对象当中有一个get和set方法</span><br><span class="line">    </span><br><span class="line">            //然后就在getData执行时调用cache.set()</span><br><span class="line">    </span><br><span class="line">            var cache = cacheData();</span><br><span class="line">    </span><br><span class="line">            getData();//加载首屏数据</span><br><span class="line">    </span><br><span class="line">            //获取数据方法</span><br><span class="line">    </span><br><span class="line">            //此方法一旦执行一定是个新数据</span><br><span class="line">    </span><br><span class="line">            function getData(page) &#123;</span><br><span class="line">    </span><br><span class="line">                var page = page || 1;</span><br><span class="line">    </span><br><span class="line">                myAjax(&#123;</span><br><span class="line">    </span><br><span class="line">                    url:&quot;http://localhost/movie.phpdfsa&quot;,</span><br><span class="line">    </span><br><span class="line">                    data:&#123;page:page,limit:5&#125;,</span><br><span class="line">    </span><br><span class="line">                    success:function(doc) &#123;</span><br><span class="line">    </span><br><span class="line">                        var doc = JSON.parse(doc);//获取接口返回的数据</span><br><span class="line">    </span><br><span class="line">                        // console.log(doc);</span><br><span class="line">    </span><br><span class="line">                        //在此时缓存数据</span><br><span class="line">    </span><br><span class="line">                        //因为只要执行了getData方法一定是个新数据</span><br><span class="line">    </span><br><span class="line">                        //一定需要缓存</span><br><span class="line">    </span><br><span class="line">                        cache.set(page,doc);</span><br><span class="line">    </span><br><span class="line">                        //请求到的新数据直接渲染</span><br><span class="line">    </span><br><span class="line">                        renderData(doc);</span><br><span class="line">    </span><br><span class="line">                    &#125;</span><br><span class="line">    </span><br><span class="line">                &#125;);</span><br><span class="line">    </span><br><span class="line">            &#125;;</span><br><span class="line">    </span><br><span class="line">            //闭包的作用 作用域的变量不会被GC回收 覆盖</span><br><span class="line">    </span><br><span class="line">            var oUl = document.querySelector(&apos;.flex_row&apos;);</span><br><span class="line">    </span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">            //写一个类来做缓存池</span><br><span class="line">    </span><br><span class="line">            //缓存里面有两个方法,</span><br><span class="line">    </span><br><span class="line">            //一个用来设置,一个用来读取</span><br><span class="line">    </span><br><span class="line">            function cacheData() &#123;</span><br><span class="line">    </span><br><span class="line">                //因为使用来操作缓存的,所以需要var一个缓存</span><br><span class="line">    </span><br><span class="line">                //所有的缓存都放在这个缓存池变量里面</span><br><span class="line">    </span><br><span class="line">                //而为什么这个缓存变量是个对象呢</span><br><span class="line">    </span><br><span class="line">                //因为在这个对象里面key和value</span><br><span class="line">    </span><br><span class="line">                //key里可以直接放page</span><br><span class="line">    </span><br><span class="line">                //value直接放相对应的数据</span><br><span class="line">    </span><br><span class="line">                //所以说用一个对象的形式</span><br><span class="line">    </span><br><span class="line">                //这个对象是专门存数据的</span><br><span class="line">    </span><br><span class="line">                var cache = &#123;&#125;;//声明一个缓存池变量</span><br><span class="line">    </span><br><span class="line">                //那么操作数据的方法呢</span><br><span class="line">    </span><br><span class="line">                //因为是为了外界能够得到这个数据</span><br><span class="line">    </span><br><span class="line">                //所以要通过闭包让cache不会被回收</span><br><span class="line">    </span><br><span class="line">                //所以要return一个函数</span><br><span class="line">    </span><br><span class="line">                //但是因为要暴露两个方法</span><br><span class="line">    </span><br><span class="line">                //第一个方法是读取方法,第二个是设置方法</span><br><span class="line">    </span><br><span class="line">                //所以要return一个对象</span><br><span class="line">    </span><br><span class="line">                //这个对象当中有两个方法</span><br><span class="line">    </span><br><span class="line">                //第一个方法是set方法</span><br><span class="line">    </span><br><span class="line">                //第二个是get方法</span><br><span class="line">    </span><br><span class="line">                return &#123;</span><br><span class="line">    </span><br><span class="line">                    //set是用来存储新数据的</span><br><span class="line">    </span><br><span class="line">                    set:function(page,doc) &#123;</span><br><span class="line">    </span><br><span class="line">                        //那么在什么时候缓存数据</span><br><span class="line">    </span><br><span class="line">                        //应该在我们getData方法时缓存数据</span><br><span class="line">    </span><br><span class="line">                        //接收到page和doc就直接存进去</span><br><span class="line">    </span><br><span class="line">                        cache[page] = doc;//缓存</span><br><span class="line">    </span><br><span class="line">                    &#125;,//存储新数据</span><br><span class="line">    </span><br><span class="line">                    //get是用来读取数据的</span><br><span class="line">    </span><br><span class="line">                    //这样在缓存池中</span><br><span class="line">    </span><br><span class="line">                    //就会完成一个读一个写的动作</span><br><span class="line">    </span><br><span class="line">                    get:function(page) &#123;</span><br><span class="line">    </span><br><span class="line">                        //什么时候读数据</span><br><span class="line">    </span><br><span class="line">                        //点击的时候读数据</span><br><span class="line">    </span><br><span class="line">                        //所以点击的时候不是获取数据了而是读数据</span><br><span class="line">    </span><br><span class="line">                        //也就是读缓存</span><br><span class="line">    </span><br><span class="line">                        //度缓存就必须要传进来页数参数page</span><br><span class="line">    </span><br><span class="line">                        //要读第几页的数据</span><br><span class="line">    </span><br><span class="line">                        //那么毒缓存就需要判断缓存里是否存在这个数据</span><br><span class="line">    </span><br><span class="line">                        //所以要if判断,判断page是不是在cache属性内</span><br><span class="line">    </span><br><span class="line">                        //如果page在缓存池的变量当中就证明这是一个旧的数据</span><br><span class="line">    </span><br><span class="line">                        //不在就是一个新的数据</span><br><span class="line">    </span><br><span class="line">                        //in用来判断对象有没有这个key</span><br><span class="line">    </span><br><span class="line">                        if (page in cache) &#123;</span><br><span class="line">    </span><br><span class="line">                            //如果存在 就证明是一个已经缓存的数据</span><br><span class="line">    </span><br><span class="line">                            //如果已经缓存了</span><br><span class="line">    </span><br><span class="line">                            //那么直接渲染数据就可以</span><br><span class="line">    </span><br><span class="line">                            //就找到page页的cache数据</span><br><span class="line">    </span><br><span class="line">                            renderData(cache[page]);</span><br><span class="line">    </span><br><span class="line">                            console.log(&apos;页面第&apos;+page+&apos;数据已经缓存,无需再次请求&apos;);</span><br><span class="line">    </span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">    </span><br><span class="line">                            //如果不在</span><br><span class="line">    </span><br><span class="line">                            //就证明是一个新的数据,就直接通过getdata方法读取数据</span><br><span class="line">    </span><br><span class="line">                            getData(page);</span><br><span class="line">    </span><br><span class="line">                        &#125;</span><br><span class="line">    </span><br><span class="line">                    &#125; //读取数据</span><br><span class="line">    </span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">            //var一个content</span><br><span class="line">    </span><br><span class="line">            var oContent = document.querySelector(&apos;.content&apos;);</span><br><span class="line">    </span><br><span class="line">            oUl.addEventListener(&apos;click&apos;,function(e) &#123;</span><br><span class="line">    </span><br><span class="line">                var e = e || window.event;//兼容</span><br><span class="line">    </span><br><span class="line">                // console.log(e.target.tagName);</span><br><span class="line">    </span><br><span class="line">                if(e.target.tagName.toLowerCase() == &apos;li&apos;) &#123;</span><br><span class="line">    </span><br><span class="line">                    // console.log(0);</span><br><span class="line">    </span><br><span class="line">                    //什么时候读数据</span><br><span class="line">    </span><br><span class="line">                    //点击的时候读数据</span><br><span class="line">    </span><br><span class="line">                    //所以点击的时候不是获取数据了而是读数据</span><br><span class="line">    </span><br><span class="line">                    //也就是读缓存</span><br><span class="line">    </span><br><span class="line">                    //读第几页数据呢,要传进去页数</span><br><span class="line">    </span><br><span class="line">                    //要在get里读数据,需要知道缓存里是否存在这个数据</span><br><span class="line">    </span><br><span class="line">                    var page = e.target.innerText;</span><br><span class="line">    </span><br><span class="line">                    // getData(page);</span><br><span class="line">    </span><br><span class="line">                    cache.get(page);</span><br><span class="line">    </span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">            &#125;);//事件监听</span><br><span class="line">    </span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">            //渲染数据的方法</span><br><span class="line">    </span><br><span class="line">            //因为要渲染数据所以要得到数据</span><br><span class="line">    </span><br><span class="line">            function renderData(data) &#123;</span><br><span class="line">    </span><br><span class="line">                //得到数据后把数据放哪里呢</span><br><span class="line">    </span><br><span class="line">                //要把数据放到content里面</span><br><span class="line">    </span><br><span class="line">                var str = &apos;&apos;;//先放一个空字符串</span><br><span class="line">    </span><br><span class="line">                //通过data的数量来生成一个一个的a标签</span><br><span class="line">    </span><br><span class="line">                //因为得到的数据是是数组(通过JSON.parse方法已经得到数据)</span><br><span class="line">    </span><br><span class="line">                //所以需要遍历数组</span><br><span class="line">    </span><br><span class="line">                //通过foreach方法</span><br><span class="line">    </span><br><span class="line">                //注意!!!!!!forEach方法需要大写!!!!</span><br><span class="line">    </span><br><span class="line">                data.forEach(function(element)&#123;</span><br><span class="line">    </span><br><span class="line">                    //得到具体的数据</span><br><span class="line">    </span><br><span class="line">                    console.log(element);</span><br><span class="line">    </span><br><span class="line">                    //那么我们在什么时间段遍历数据</span><br><span class="line">    </span><br><span class="line">                    //在渲染数据的时候遍历数据</span><br><span class="line">    </span><br><span class="line">                    //什么时候渲染数据</span><br><span class="line">    </span><br><span class="line">                    //正鞥而流程就是通过点击事件读取数据(缓存)</span><br><span class="line">    </span><br><span class="line">                    //判断缓存里面是否存在</span><br><span class="line">    </span><br><span class="line">                    //如果存在就直接数据请求</span><br><span class="line">    </span><br><span class="line">                    //没有缓存就新请求getData,而在getData里面我们又会</span><br><span class="line">    </span><br><span class="line">                    //set设置缓存</span><br><span class="line">    </span><br><span class="line">                    //那么真正渲染数据的时候</span><br><span class="line">    </span><br><span class="line">                    //一个是缓存当中有数据的时候就直接渲染数据</span><br><span class="line">    </span><br><span class="line">                    //一个是每次请求新数据的时候都需要渲染一波</span><br><span class="line">    </span><br><span class="line">                    //这是字符串模板 ``</span><br><span class="line">    </span><br><span class="line">                    //这个玩意完全可以用+去拼接</span><br><span class="line">    </span><br><span class="line">                    //把a标签里所有的东西都拿过来去拼接</span><br><span class="line">    </span><br><span class="line">                    //然后就是修改里面的动态数据</span><br><span class="line">    </span><br><span class="line">                    //一:链接href数据是动态的,链接里数组里有</span><br><span class="line">    </span><br><span class="line">                    //用拼接模板拼接$</span><br><span class="line">    </span><br><span class="line">                    str += `</span><br><span class="line">    </span><br><span class="line">                        &lt;a href=&quot;$&#123;element.url&#125;&quot; class=&quot;items flex_row&quot;&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;div class=&quot;img&quot;&gt;</span><br><span class="line">    </span><br><span class="line">                                &lt;img src=&quot;$&#123;element.cover&#125;&quot;&gt;</span><br><span class="line">    </span><br><span class="line">                            &lt;/div&gt;</span><br><span class="line">   </span><br><span class="line">                        &lt;div class=&quot;bd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">                            &lt;p class=&quot;label&quot;&gt;$&#123;element.title&#125;&lt;/p&gt;</span><br><span class="line">    </span><br><span class="line">                            &lt;/div&gt;</span><br><span class="line">                        &lt;div class=&quot;ft&quot;&gt;&amp;GT;&lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">                        &lt;/a&gt;</span><br><span class="line">    </span><br><span class="line">                    `;</span><br><span class="line">    </span><br><span class="line">                    //上面的字符串一旦收集完毕就把他赋值给oContent</span><br><span class="line">    </span><br><span class="line">                    oContent.innerHTML = str;</span><br><span class="line">    </span><br><span class="line">                &#125;);</span><br><span class="line">    </span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // var oLi = document.querySelectorAll(&apos;.flex_row li&apos;);</span><br><span class="line">    </span><br><span class="line">            // for (var i = 0; i&lt;oLi.length ; i++)</span><br><span class="line">    </span><br><span class="line">            // &#123;</span><br><span class="line">    </span><br><span class="line">            //  (function(i) &#123;</span><br><span class="line">    </span><br><span class="line">            //      oLi[i].onclick = function() &#123;</span><br><span class="line">    </span><br><span class="line">            //          getData(i+1);</span><br><span class="line">    </span><br><span class="line">            //          // console.log(i);</span><br><span class="line">    </span><br><span class="line">            //      &#125;</span><br><span class="line">    </span><br><span class="line">            //  &#125;)(i);</span><br><span class="line">    </span><br><span class="line">            // &#125;</span><br><span class="line">    </span><br><span class="line">        &lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>关于MySQL事物隔离</title>
      <link href="/2018/10/21/%E5%85%B3%E4%BA%8EMySQL%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB/"/>
      <url>/2018/10/21/%E5%85%B3%E4%BA%8EMySQL%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="事物隔离"><a href="#事物隔离" class="headerlink" title="事物隔离"></a>事物隔离</h1><blockquote><p>简单概念:</p><p>事物就是保证一组数据库操作,要么全部成功,要么全部失败</p></blockquote><p>那么事物在数据库中如何实现?</p><p>以MySQL为例,MySQL是一个支持多引擎的数据库,常见的MySQL引擎有MyISAM 和 InnoDB, 其中MyISAM不支持事物, 而InnoDB支持事物,也就是说,在MySQL中,事物是在引擎层实现的. 这也是MyISAM被InnoDB取代的重要原因之一.</p><p>事物特性: </p><ul><li>原子性(Atomicity)</li><li>一致性(Consistency)</li><li>隔离性(Isolation)</li><li>持久性(Durability)</li></ul><p>关于隔离性</p><p>当数据库上有多个事物同时执行时,可能出现</p><ul><li>脏读(dirty read)</li><li>不可重复读(non reapeatable read)</li><li>幻读(phantom read)</li></ul><p>为了解决这些问题,有了隔离级别,但隔离有利弊,隔离越严,效率越低. 所以要选择合适的隔离级别.</p><p>SQL标准的事物隔离级别包括:</p><ul><li><p>读未提交(read uncommitted)</p><p>未提交就可读</p><p>一个事物A还未提交,它已做的变更就能被别的事物B看到,也就是事务A执行过程中,别的事物B可以看到事物A的变更.</p><p>读未提交级别下,没有视图概念, 因为直接返回记录上的最新值. </p></li><li><p>rc读提交（read committed）</p><p>提交之后才能被读</p><p>一个事物A提交之后,其做的变量才能被其他事物B看到, 也就是在该隔离级别下, 事物A执行过程中, 事物B无法看到事物A所做的变更. </p><ul><li><p>如何实现?</p><p>在读提交隔离级别下, 在每个 SQL 语句开始执行的时候, 数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准. </p></li></ul></li><li><p>rr可重复读（repeatable read）</p><p>一个事物A启动时看到的数据, 和事物A执行过程中看到的数据是一样的, 也就是事物A执行过程中, 如果有别的事物B改动了数据, 是无法影响到事物A的, 因为事物A看到的数据是定格在事物A启动那一刻的视图, 在其执行过程中不受其他事物影响.  同时, 在可重复读隔离级别下, 事物A未提交的变更对其他事物也是不可见的. </p><p>一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。</p><ul><li><p>如何实现?</p><p>数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准, 在”可重复读”隔离级别下, 这个视图是在事物启动时创建的,整个事物存在期间都用这个视图. </p></li><li><p>使用场景?</p><p>数据校对场景: 假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p></li></ul><p>这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</p></li><li><p>串行化（serializable ）</p><p>一个接一个, 也就是对于同一行记录, 写会加写锁, 读会加读锁, 当读写锁冲突时, 后访问的事物必须要等前一个事物执行完成,才能继续执行.</p><ul><li>如何实现?</li></ul><p>串行化隔离级别下直接用加锁的形式避免并行访问.</p></li></ul><p>用一个例子说明这几种隔离级别。假设数据表 T 中只有一列，其中一行的值为 1，下面是按照时间顺序执行两个事务的行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(c int) engine=InnoDB;</span><br><span class="line">insert into T(c) values(1);</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">事物A</th><th style="text-align:center">事物B</th></tr></thead><tbody><tr><td style="text-align:center">启动事务,查询得到值1</td><td style="text-align:center">启动事务</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">查询得到值1</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">将1改为2</td></tr><tr><td style="text-align:center">查询得到值V1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">提交事务B</td></tr><tr><td style="text-align:center">查询得到值V2</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">提交事务A</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">查询得到值V3</td></tr></tbody></table><ul><li>若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。</li><li>若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。</li><li>若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，是因为此时事物A还未提交, 遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li><li>若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。</li></ul><p>在不同隔离级别下, 数据库的行为不同, Oracle 数据库的默认隔离级别其实就是“读提交”，因此对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，你一定要记得将 MySQL 的隔离级别设置为“读提交”。</p><p>如何配置?</p><p>将启动参数 transaction-isolation 的值设置成 READ-COMMITTED。你可以用 show variables 来查看当前的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;transaction_isolation&apos;;</span><br><span class="line"> </span><br><span class="line">+-----------------------+----------------+</span><br><span class="line"> </span><br><span class="line">| Variable_name | Value |</span><br><span class="line"> </span><br><span class="line">+-----------------------+----------------+</span><br><span class="line"> </span><br><span class="line">| transaction_isolation | READ-COMMITTED |</span><br><span class="line"> </span><br><span class="line">+-----------------------+----------------+</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构与算法之美-学习笔记3之复杂度分析上</title>
      <link href="/2018/10/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E4%B9%8B%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E4%B8%8A/"/>
      <url>/2018/10/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E4%B9%8B%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="lt-数据结构和算法之美-gt"><a href="#lt-数据结构和算法之美-gt" class="headerlink" title="&lt;数据结构和算法之美&gt;"></a>&lt;数据结构和算法之美&gt;</h1><h1 id="–学习笔记3之复杂度分析上"><a href="#–学习笔记3之复杂度分析上" class="headerlink" title="–学习笔记3之复杂度分析上"></a>–学习笔记3之复杂度分析上</h1><h2 id="1-复杂度分析重要性"><a href="#1-复杂度分析重要性" class="headerlink" title="1. 复杂度分析重要性"></a>1. 复杂度分析重要性</h2><p>数据结构和算法本身解决的是 “ 快 ” 和 “ 省 ” 的问题,而执行效率是算法一个非常重要的考量指标, 而<strong>时间、空间复杂度分析就是用来衡量代码执行效率</strong>的. </p><p>复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。</p><h2 id="2-为什么需要复杂度分析"><a href="#2-为什么需要复杂度分析" class="headerlink" title="2. 为什么需要复杂度分析?"></a>2. 为什么需要复杂度分析?</h2><ol><li>事后统计法的测试环境对测试结果影响大</li><li>测试结果受数据规模影响大</li></ol><p>综上两点,得出需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。也就是<strong>时间、空间复杂度分析方法</strong></p><h2 id="3-大O复杂度-变化趋势-表示法"><a href="#3-大O复杂度-变化趋势-表示法" class="headerlink" title="3.大O复杂度(变化趋势)表示法"></a>3.大O复杂度(变化趋势)表示法</h2><p>算法的执行效率，粗略地讲，就是算法代码执行的时间。</p><p>假设每行代码执行的时间都一样，</p><p>则<strong>所有代码的执行时间 T(n) 与每行代码的执行次数n成正比</strong>。<br>$$<br>T(n) = O(f(n))<br>$$<br><strong>T(n)</strong> 表示<strong>代码执行的时间</strong>；</p><p><strong>n</strong> 表示<strong>数据规模的大小</strong>； </p><p><strong>f(n)</strong> 表示<strong>每行代码执行的次数总和</strong>。</p><p>公式中的O ，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p><p><strong>大 O 时间复杂度</strong>实际上并不具体表示代码真正的执行时间，而是<strong>表示代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong>（ asymptotic time complexity ），简称<strong>时间复杂度</strong>。</p><p>当 n 很大时，也就是数据规模极大时, 公式中的<strong>低阶</strong>、<strong>常量</strong>、<strong>系数</strong>三部分并不左右增长趋势，所以都可以忽略。</p><p>我们只需要记录一个<strong>最大量级</strong>就可以了</p><h2 id="4-三个实用计算方法"><a href="#4-三个实用计算方法" class="headerlink" title="4.三个实用计算方法"></a>4.三个实用计算方法</h2><h3 id="1-只关注循环执行次数最多的一段代码"><a href="#1-只关注循环执行次数最多的一段代码" class="headerlink" title="1.只关注循环执行次数最多的一段代码"></a>1.只关注循环执行次数最多的一段代码</h3><p>大 O 这种复杂度表示方法只是表示一种变化趋势。</p><p>我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。</p><p>所以，我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。</p><p>这段核心代码执行次数的 n的量级，就是整段要分析代码的时间复杂度。</p><h3 id="2-加法法则：总复杂度等于量级最大的那段代码的复杂度"><a href="#2-加法法则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="2.加法法则：总复杂度等于量级最大的那段代码的复杂度"></a>2.加法法则：总复杂度等于量级最大的那段代码的复杂度</h3><p>总的时间复杂度就等于量级最大的那段代码的时间复杂度.</p><p>如果<br>$$<br>T1(n)=O(f(n)) ， T2(n)=O(g(n))<br>$$<br> 那么<br>$$<br>T(n)=T1(n)+T2(n)<br>$$</p><p>$$<br>=max(O(f(n)), O(g(n)))<br>$$</p><p>$$<br>=O(max(f(n), g(n)))<br>$$</p><p>学过高数,这些都不难理解,也就是在数据量极限情况下,量级最大的起决定作用,量级小的都可以忽略不计. </p><h3 id="3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h3><p>如果<br>$$<br>T1(n)=O(f(n)) ， T2(n)=O(g(n))<br>$$<br>那么<br>$$<br>T(n)=T1(n)*T2(n)<br>$$</p><p>$$<br>=O(f(n))*O(g(n))<br>$$</p><p>$$<br>=O(f(n)*g(n)).<br>$$</p><p>也就是说，</p><p>假设<br>$$<br>T1(n) = O(n) ， T2(n) = O(n^2)<br>$$<br>则<br>$$<br>T1(n) * T2(n) = O(n^3)<br>$$<br>落实到具体的代码上，可以把<strong>乘法法则看成是嵌套循环</strong>.</p><h2 id="5-几种常见时间复杂度实例分析"><a href="#5-几种常见时间复杂度实例分析" class="headerlink" title="5.几种常见时间复杂度实例分析"></a>5.几种常见时间复杂度实例分析</h2><p>复杂度量级分类</p><table><thead><tr><th>复杂度量级(按数量级递增)</th><th></th></tr></thead><tbody><tr><td>多项式量级</td><td>非多项式量级</td></tr><tr><td><strong>常量阶O(1)</strong></td><td>指数阶O(2^n)</td></tr><tr><td><strong>对数阶O(logn)</strong></td><td>阶乘阶O(n!)</td></tr><tr><td><strong>线性阶O(n)</strong></td><td></td></tr><tr><td><strong>线性对数阶O(nlogn)</strong></td><td></td></tr><tr><td><strong>平方阶O(n^2)</strong></td><td></td></tr><tr><td>立方阶O(n^3)</td><td></td></tr><tr><td>k次方阶O(n^K)</td></tr></tbody></table><p>非多项式量级只有两个： <del>O(2^n) 和 O(n!)</del></p><p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。</p><p>所以，<strong><del>非多项式时间复杂度的算法其实是非常低效的算法</del></strong>。</p><h3 id="1-O-1"><a href="#1-O-1" class="headerlink" title="1.O(1)"></a>1.O(1)</h3><p> O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。</p><p>只要<strong>代码的执行时间不随 n 的增大而增长</strong>，这样代码的时间复杂度我们都记作O(1) 。</p><p>或者说，一般情况下，<strong>只要算法中不存在循环语句、递归语句，即使有成千上万行的代码</strong>，其时间复杂度也是 Ο(1) 。</p><h3 id="2-O-logn-、-O-nlogn"><a href="#2-O-logn-、-O-nlogn" class="headerlink" title="2.O(logn) 、 O(nlogn)"></a>2.O(logn) 、 O(nlogn)</h3><p>这部分比较难理解,需要下来多看多练.</p><p>一般是<strong>循环里面的变量每次以以固定倍数增长的情况下</strong>,会出现这种<strong>O(logn)</strong>复杂度.且不管倍数为哪一个固定的数,对数是可以互相转化的,这个固定的数最后多会转为系数,</p><p><strong>在采用大 O 标记复杂度的时候，可以忽略系数，</strong></p><p>即 <strong>O(C f(n)) = O(f(n))</strong></p><p>所以， <strong>O(log n) 就等于 O(log n)</strong> 。</p><p>因此，<strong>在对数阶时间复杂度的表示方法里，我们忽略对数的 “ 底 ” ，统一表示为 O(logn)</strong></p><p><strong>O(nlogn)</strong>根据<strong>乘法法则</strong>(<strong>也就是嵌套循环</strong>),可以得到<strong>n*logn</strong></p><p>如果一段代码的时间复杂度是 O(logn) ，我们<strong>循环执行 n 遍</strong>，时间复杂度就是 O(nlogn) 了。</p><p>而且， O(nlogn) 也是一种非常常见的算法时间复杂度。</p><h3 id="3-O-m-n-、-O-m-n"><a href="#3-O-m-n-、-O-m-n" class="headerlink" title="3.O(m+n) 、 O(m*n)"></a>3.O(m+n) 、 O(m*n)</h3><p>代码的复杂度由两个(也可能多个)数据的规模m和n来决定</p><p>m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以时间复杂度就是 O(m+n).</p><p>加法规则变为<br>$$<br>T1(m) + T2(n) = O(f(m) + g(n))<br>$$<br>乘法规则(嵌套循环)变为<br>$$<br> T1(m)<em>T2(n) = O(f(m) </em> f(n))<br>$$</p><h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>时间复杂度的全称是<strong>渐进时间复杂度</strong>，</p><p>表示<strong>算法的执行时间与数据规模之间的增长关系</strong>。</p><p>空间复杂度全称就是<strong>渐进空间复杂度</strong>，</p><p>表示<strong>算法的存储空间与数据规模之间的增长关系</strong>。</p><p>常见的空间复杂度就是 O(1) 、 O(n) 、 O(n^2)</p><p>若申请一个空间存储某一变量, 常量阶的，跟数据规模 n 没有关系，所以我们可以忽略</p><p>若申请了一个大小为 n 的 int 类型数组, 则整段代码的空间复杂度就是 O(n) .</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，<strong>越高阶复杂度的算法，执行效率越低</strong>。</p><p><strong>常见的复杂度并不多，从低阶到高阶有： O(1) 、 O(logn) 、 O(n) 、 O(nlogn) 、 O(n^2) 。</strong></p><p>多项式阶 : 常数阶,对数阶,线性阶,线性对数阶,平方阶</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>附一下评论区大佬的总结</p><p>一、什么是复杂度分析？</p><p>数据结构和算法解决是 “ 如何让计算机更快时间、更省空间的解决问题 ” 。</p><p>因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。</p><p>分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。</p><p>复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。</p><p>二、为什么要进行复杂度分析？</p><p>和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。</p><p>掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。</p><p>三、如何进行复杂度分析？</p><p>大 O 表示法</p><p>1 ）来源<br>算法的执行时间与每行代码的执行次数成正比，用 T(n) = O(f(n)) 表示，其中 T(n) 表示算法执行总时间， f(n) 表示每行代码执行总次数，而 n 往往表示数据的规模。<br>2 ）特点<br>以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。</p><p>复杂度分析法则</p><p>1 ）单段代码看高频：比如循环。<br>2 ）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。<br>3 ）嵌套代码求乘积：比如递归、多重循环等<br>4 ）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。</p><p>四、常用的复杂度级别？</p><p>多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，<br>O(1) （常数阶）、 O(logn) （对数阶）、 O(n) （线性阶）、 O(nlogn) （线性对数阶）、 O(n^2) （平方阶）、 O(n^3) （立方阶）<br>非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，O(2^n) （指数阶）、 O(n!) （阶乘阶）</p><p>五、如何掌握好复杂度分析方法？</p><p>复杂度分析关键在于多练，所谓孰能生巧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构和算法,算法复杂度 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
